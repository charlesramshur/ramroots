name: Update README Status

on:
  workflow_dispatch:
  schedule:
    - cron: "*/30 * * * *"  # every 30 minutes

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    env:
      VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      GH_PUSH_TOKEN: ${{ secrets.GH_PUSH_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build status block
        run: |
          node - <<'NODE'
          const fs = require('fs');
          

          const fmt = (d)=> new Date(d).toISOString().replace('T',' ').slice(0,16)+' UTC';

          async function vercel() {
            const r = await fetch(`https://api.vercel.com/v13/deployments?projectId=${process.env.VERCEL_PROJECT_ID}&limit=1`, {
              headers: { Authorization: `Bearer ${process.env.VERCEL_TOKEN}` }
            });
            const j = await r.json();
            const d = j.deployments?.[0] || {};
            return {
              status: d.readyState || 'UNKNOWN',
              when: d.createdAt ? fmt(d.createdAt) : '—',
              url: d.url ? `https://${d.url}` : ''
            };
          }

          async function render() {
            const srv = process.env.RENDER_SERVICE_ID;
            const headers = { Authorization: `Bearer ${process.env.RENDER_API_KEY}` };
            const r1 = await fetch(`https://api.render.com/v1/services/${srv}`, { headers });
            const s = await r1.json();
            const r2 = await fetch(`https://api.render.com/v1/services/${srv}/deploys?limit=1`, { headers });
            const d = (await r2.json())?.[0] || {};
            return {
              status: s?.service?.status || s?.status || 'UNKNOWN',
              when: d?.createdAt ? fmt(d.createdAt) : '—',
              sha: d?.commit?.id ? d.commit.id.slice(0,7) : (s?.deploy?.commitId ? s.deploy.commitId.slice(0,7) : '—'),
              dash: `https://dashboard.render.com/web/${srv}`
            };
          }

          async function github() {
            const { execSync } = require('child_process');
            const sha = execSync('git rev-parse --short HEAD').toString().trim();
            const msg = execSync('git log -1 --pretty=%s').toString().trim();
            const when = execSync('git log -1 --pretty=%cI').toString().trim();
            const link = `https://github.com/${process.env.GITHUB_REPOSITORY}/commit/${execSync('git rev-parse HEAD').toString().trim()}`;
            return { sha, msg, when: fmt(when), link };
          }

          (async () => {
            const v = await vercel().catch(()=>({status:'ERROR', when:'—', url:''}));
            const r = await render().catch(()=>({status:'ERROR', when:'—', sha:'—', dash:''}));
            const g = await github();

            const block =
`**Repo:** ${process.env.GITHUB_REPOSITORY}
**Branch:** ${process.env.GITHUB_REF_NAME || 'main'}

| Service | Status | When | Link |
|---|---|---|---|
| GitHub | Commit \`${g.sha}\` — ${g.msg} | ${g.when} | [View](${g.link}) |
| Vercel | ${v.status} | ${v.when} | ${v.url ? `[Open](${v.url})` : '—'} |
| Render (api) | ${r.status}<br/><sub>Commit \`${r.sha}\`</sub> | ${r.when} | ${r.dash ? `[Dashboard](${r.dash})` : '—'} |

_Last updated: ${fmt(Date.now())}_
`;

            const readme = fs.readFileSync('README.md','utf8');
            const out = readme.replace(
              /<!-- STATUS-START -->[\\s\\S]*<!-- STATUS-END -->/,
              `<!-- STATUS-START -->\n${block}\n<!-- STATUS-END -->`
            );
            fs.writeFileSync('README.md', out);
          })();
          NODE

      - name: Commit README update
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: auto-update README status"
