const express = require('express');
const router = express.Router();
const OpenAI = require('openai');
const { memoryContext } = require('../engine/memory.cjs');
const { parseRepo, octo, createBranch, upsert, openPR, mergePR } = require('../agents/builder.cjs');

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';
const BASE_BRANCH = process.env.GITHUB_DEFAULT_BRANCH || 'main';
function baseURL(){ const port=process.env.PORT||'5000'; return http://localhost:; }

function guardFiles(files){
  const denied=[/^\.env/i,/^vercel\./i,/^\.github\/workflows\//i];
  const roots=['src/','server/','public/','docs/'];
  if(!Array.isArray(files)) return [];
  const keep = files.filter(f=> f && f.path && typeof f.content==='string' && roots.some(r=>f.path.startsWith(r)) && !denied.some(rx=>rx.test(f.path)) ).slice(0,15);
  const total = keep.reduce((n,f)=> n + (f.content||'').split('\n').length, 0);
  return total>2000 ? keep.slice(0, Math.max(1, Math.floor(2000/ Math.max(1, (keep[0]?.content||'').split('\n').length)))) : keep;
}

router.post('/propose', async (req,res)=>{
  try{
    const request = String(req.body?.request||'').trim();
    if(!request) return res.status(400).json({ error:'empty_request' });

    const coach = await fetch(${baseURL()}/api/coach, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ request })
    }).then(r=>r.json());

    const sys = 'You are RamRoot\\'s BUILDER. Reply ONLY with JSON: {\"files\":[{\"path\":\"src/...\",\"content\":\"file contents\"}]}';
    const mem = memoryContext();
    const user = ${mem}\nPlan:\nGenerate minimal diffs to satisfy acceptance_criteria. Avoid boilerplate.;

    const out = await client.chat.completions.create({ model: MODEL, temperature: 0.1,
      messages:[ {role:'system', content: sys}, {role:'user', content: user} ] });
    let files=[]; try{ files = JSON.parse(out.choices?.[0]?.message?.content||'{\"files\":[]}').files; } catch{ files=[]; }
    files = guardFiles(files);

    const { owner, repo } = parseRepo();
    const o = octo();
    const branch = amroot/;
    await createBranch(o, owner, repo, BASE_BRANCH, branch);
    for(const f of files){ await upsert(o, owner, repo, branch, f.path, f.content); }
    const pr = await openPR(o, owner, repo, BASE_BRANCH, branch, RamRoot: , Auto-generated by Builder.\n\nPlan: );

    res.json({ pr_number: pr.number, pr_url: pr.html_url, branch, files_count: files.length, coach });
  }catch(e){ console.error('builder propose error', e); res.status(500).json({ error:'builder_failed', message:String(e?.message||e) }); }
});

async function appendDecision(o, owner, repo, title, pr){
  const path='docs/decisions.md';
  const stamp = -  —  ([#]());
  let current=''; let sha;
  try{
    const { data } = await o.repos.getContent({ owner, repo, path, ref: BASE_BRANCH });
    if(!Array.isArray(data)){ current = Buffer.from(data.content, 'base64').toString('utf8'); sha=data.sha; }
  } catch {}
  const next = (current? current + '\n' : '# Decisions\n\n') + stamp + '\n';
  await o.repos.createOrUpdateFileContents({ owner, repo, path, message:'docs: log decision', content: Buffer.from(next).toString('base64'), branch: BASE_BRANCH, sha });
}

router.post('/merge', async (req,res)=>{
  try{
    const pr_number = Number(req.body?.pr_number); if(!pr_number) return res.status(400).json({ error:'missing_pr_number' });
    const title = String(req.body?.title || 'Merged by RamRoot');
    const { owner, repo } = parseRepo();
    const o = octo();
    await mergePR(o, owner, repo, pr_number);
    const pr = { number: pr_number, html_url: https://github.com///pull/ };
    await appendDecision(o, owner, repo, title, pr);
    res.json({ merged:true });
  }catch(e){ console.error('builder merge error', e); res.status(500).json({ error:'merge_failed', message:String(e?.message||e) }); }
});

module.exports = router;
